Unit_name: Intro to Golang & Basic Concurrency
Page_name: A touch of concurrency

1. Consider the following Go code snippet. What does it do?

    ```go
    go func() {
        fmt.Println("Hello, Goroutine!")
    }()
    ```

    A) It prints "Hello, Goroutine!" in a new thread.
    - Correct. The `go` keyword runs the function in a new Goroutine - a lightweight thread managed by the Go runtime.

    B) It will not print anything since there is no call to a wait function.
    - Incorrect. While it's true that the main function may terminate before the Goroutine gets to run (thus never printing anything), this code intends to print a message in a new Goroutine.

    C) It results in a compile error.
    - Incorrect. The code is valid and runs without compilation errors.


2. Consider the following Go code. What is its role in the context of Goroutines?

    ```go
    ch := make(chan int)
    ```

    A) It declares an integer variable.
    - Incorrect. This statement creates a new channel of integers, not a regular integer variable.

    B) It creates a new channel of integers.
    - Correct. In Go, the `make(chan int)` statement creates a new channel that can transmit integers between Goroutines.

    C) It reserves memory for the integer type.
    - Incorrect. It creates a channel for integers, it does not reserve memory for the integer type.


3. Consider this Go code:

    ```go
    select {
    case <-ch1:
        fmt.Println("Received from ch1!")
    case ch2 <- 1:
        fmt.Println("Sent to ch2!")
    }
    ```

    What is the primary purpose of the `select` statement here?

    A) To open and close channels.
    - Incorrect. The select statement isn't used to open or close channels directly but to manage channel operations.

    B) To wait for either a receive from `ch1` or a send to `ch2`.
    - Correct. The `select` statement waits on multiple channel operations. Here it waits for either a receive operation from `ch1` or a send operation to `ch2`.

    C) To execute all cases concurrently.
    - Incorrect. The `select` statement does not execute all cases concurrently, it waits on any of the case statements to be ready.


4. How does the `sync.Mutex` type contribute to Goroutine synchronization?

    A) It allows Goroutines to communicate directly.
    - Incorrect. Communication between Goroutines is primarily done with channels, not Mutexes.

    B) It provides a lock that can be used to control access to shared data.
    - Correct. A `sync.Mutex` is a mutual exclusion lock. It can enforce exclusive access to shared data, minimizing race conditions.

    C) It blocks all Goroutines until a certain condition is met.
    - Incorrect. While Mutexes do block Goroutines, they're not about waiting for conditions directly, they're used to guard shared data.

Continue the list according to the given template.

1. Consider a function 'compute()' which takes significant computational time. How would you modify it in Go to run concurrently?

    A) Apply async before the function call - async compute()
    - Incorrect. Go language does not have 'async' keyword. You might be confusing with other languages.
  
    B) Apply go before the function call - go compute()
    - Correct. In Go, using the 'go' keyword before the function call will make the compute() function call execute concurrently.
    
    C) Apply goroutine before the function call - goroutine compute()
    - Incorrect. There's the keyword 'goroutines' not 'goroutine', but it's not used this way. You may need to revisit the usage of goroutines.

4. Consider a Go program with two goroutines 'A' and 'B'. How can Goroutine 'A' send a integer value '5' to Goroutine 'B'?

    A) A --- 5 ---> B
    - Incorrect. This seems like a diagrammatic representation of the intended action. You need to consider what construct in Go allows communication between goroutines.
    
    B) channel <- 5
    - Incorrect. This expression is partly correct, it only specifies the value being sent into a channel, not the receiving goroutine. Remember, channels have both send and receive operators.
    
    C) channel <- 5
    - Correct. This is the correct syntax in Go. The channel takes in a value with '<-' operator. Goroutine 'B' can receive this value by 'value := <-channel'.

10. If you have a Goroutine 'A' that should print 'Hello' after Goroutine 'B' prints 'World', how will you implement it? 

```
    go fmt.Println("World")
    go fmt.Println("Hello")
```

    A) The code will print 'World' and 'Hello' in that order.
    - Incorrect. Using the `go` keyword executes the function concurrently, so there's no guaranteed sequence of execution. You are missing a significant concept here.
    
    B) The print statements will cause an error because goroutines cannot output to the console.
    - Incorrect. Goroutines are fully capable of printing to console. The problem lies in controlling the order of execution here.
    
    C) The code will not necessarily print 'World' before 'Hello'.
    - Correct. As goroutines execute concurrently, the order of execution is not necessarily the order of declaration. Using channels to sync between these goroutines can help maintain a specific order.

1. In `Go`, how can we create an `unbuffered` channel of `integers`?

    A) `ch := make(chan int, 0)`
    - Incorrect. While it's good you're using `make` to create a channel, specifying a buffer with size `0` won't create an unbuffered channel. Consider what it means for a channel to be unbuffered.
  
    B) `ch := make(chan int)`
    - Correct, well done. For an unbuffered channel, we only need to specify the "channel of int", and don't provide any buffer size argument.
    
    C) `ch := new(chan int)`
    - Incorrect. While `new` is also a built-in function in `Go`, it's not used to create channels. Remember what we use to create a channel.

2. When creating a channel in `Go`, what's the implication of using the buffer size argument?

    A) It determines how many values the channel can simultaneously hold.
    - Correct. The buffer size does define the maximum number of values a channel can hold before sending goroutine blocks.
  
    B) It defines the data type of values stored in the channel.
    - Incorrect. The buffer size doesn't define the type of stored values. The type of the channel defines this.
    
    C) It determines the total number of channels that can be created.
    - Incorrect. The number of channels that can be created is not influenced by the buffer size when creating one channel. Consider the role of buffer size.

3. Given the following code in `Go`, what are the potential consequences? `dataStream := make(chan int); go func() { dataStream <- 4 }()`

    A) The program may not terminate and hang.
    - Correct. If there's no corresponding receiver ready to consume the sent value, the sender goroutine will be blocked, causing the program to hang.
  
    B) The data `4` will be lost from the memory.
    - Incorrect. The data isn't lost, but the process is blocked until a receiver goroutine is ready to fetch the value from the unbuffered channel.
    
    C) `Go` runtime will throw an unhandled exception.
    - Incorrect. `Go` runtime will not trigger any exceptions. In fact, Go doesnâ€™t have exceptions at all in the usual sense.

4. Examine the following code snippet. If it's intended to create a buffered channel with capacity `5`, what change is necessary? `ch := make(chan, 5)`

    A) Change to `ch := make(chan int, 5)`
    - Correct. We must specify the channel's type before defining its buffer size. Well done.
    
    B) Change `5` to `"5"`
    - Incorrect. While '5' seems to represent the intention for a buffer of size 5, remember what data type should represent the buffer size.
    
    C) Add `new` before `chan`
    - Incorrect. The `new` keyword isn't used to create channels in Go. Consider how we establish a channel.

5. How does an unbuffered channel synchronize concurrent `Go` Routines?

    A) It allows both simultaneous transmission and reception of data.
    - Incorrect. This isn't quite right. Unbuffered channels don't accommodate simultaneous transmission and reception. Consider what happens when data is sent but not immediately received.
    
    B) It waits until the receiver is ready before sending the data.
    - Correct. Unbuffered channels do synchronize communication, data is only sent when a receiver is ready.
    
    C) It sends the data immediately, even if no receiver is ready.
    - Incorrect. This isn't how unbuffered channels work. Think about how a transmission occurs when there isn't a receiver ready.

6. Analyze the following scenario: You have a buffered `channel` of size `5`, which is already full of values. Now, a sender tries to send another value to this channel. What's likely to be the result?

    A) An exception is triggered by `Go`.
    - Incorrect. `Go` language doesn't work with exceptions in such cases. Remember what happens when a full buffered channel gets another send request.
  
    B) The sender goroutine is blocked until there's space in the channel.
    - Correct. When a buffered channel is full, any further send operation would block until there is space in the buffer.
    
    C) The most recent value in the channel is replaced by the new value.
    - Incorrect. This isn't correct as buffered channels don't overstep their designated size. Consider what means `Go` takes to enforce the 'bounded buffer' rule.

7. In `Go`, how can we create a buffered channel of strings that holds up to `10` values without blocking?

    A) `eventStream := make(chan string, 10)`
    - Correct. You've created a buffered channel correctly. Well done!
    
    B) `eventStream := new([10]chan string)`
    - Incorrect. We use `make` to create channels. And in Go, channels aren't usually used in conjunction with arrays like this.
    
    C) `eventStream := make(chan []string, 10)`
    - Incorrect. While it seems correct, this would actually create a channel of `string` slice with a buffer of size `10`, not a buffered channel of `string` that can hold `10` values.

8. Consider the scenario: A receiver goroutine tries to receive a value from an empty channel with no sending goroutine. What happens?

    A) The receiver goroutine blocks until there's a value available on the channel.
    - Correct. In this situation, the receiver blocks because there's no available value to be received from the channel.
    
    B) `Go` runtime triggers an unhandled exception.
    - Incorrect. `Go` language doesn't handle this situation with exceptions. What happens to the receiver when there's no value to receive?
    
    C) The empty channel is automatically closed by `Go` runtime.
    - Incorrect. Empty channels aren't automatically closed in `Go`. Consider what happens to the receiver when it waits for a value from an empty channel.